# This file has been generated by Niv.

# A record, from name to path, of the third-party packages
{ overlays ? [] }:
let 
  # borrowed from nixpkgs
  extends = f: rattrs: self: let super = rattrs self; in super // f self super;
  fix = f: let x = f x; in x;
  functionArgs = f: f.__functionArgs or (builtins.functionArgs f);
  flip = f: a: b: f b a;
  callFunctionWith = autoArgs: f: args:
    let auto = builtins.intersectAttrs (functionArgs f) autoArgs;
    in f (auto // args);
  mapAttrs = builtins.mapAttrs or
    (f: set: with builtins;
      listToAttrs (map (attr: { name = attr; value = f attr set.${attr}; }) (attrNames set)));

  hasNixpkgsPath = (builtins.tryEval <nixpkgs>).success;
  hasThisAsNixpkgsPath =
    (builtins.tryEval <nixpkgs>).success && <nixpkgs> == ./.;

  niv-overlay = self: super: {
    nixpkgs = 
      if hasNixpkgsPath && !hasThisAsNixpkgsPath
      then <nixpkgs>
      else super.nixpkgs;

    __fetchers = {
      # A wrapper around pkgs.fetchzip that has inspectable arguments,
      # annoyingly this means we have to specify them
      tarball = { url, sha256 }@attrs: (import self.nixpkgs {}).fetchzip attrs;
      # fetchTarball version that is compatible between all the versions of Nix
      builtin-tarball = { url, sha256 }@attrs:
        let inherit (builtins) lessThan nixVersion fetchTarball;
        in
          if lessThan nixVersion "1.12" 
          then fetchTarball { inherit url; }
          else fetchTarball attrs;
      # A wrapper around pkgs.fetchurl that has inspectable arguments,
      # annoyingly this means we have to specify them
      file = { url, sha256 }@attrs: (import self.nixpkgs {}).fetchurl attrs;
      # fetchurl version that is compatible between all the versions of Nix
      builtin-url = { url, sha256 }@attrs:
        let inherit (builtins) lessThan nixVersion fetchurl;
        in
          if lessThan nixVersion "1.12" 
          then fetchurl { inherit url; }
          else fetchurl attrs;
    };
  };

  sources = builtins.fromJSON (builtins.readFile ./sources.json);

  sources-overlay = self: super:
    let getFetcher = spec:
      let fetcherName =
        if builtins.hasAttr "type" spec
        then builtins.getAttr "type" spec
        else "builtin-tarball";
      in builtins.getAttr fetcherName (self.__fetchers);
    in mapAttrs (_: spec:
      # NOTE: spec must _not_ have an "outPath" attribute
      if builtins.hasAttr "outPath" spec
      then abort
        "The values in sources.json should not have an 'outPath' attribute"
      else
        if builtins.hasAttr "url" spec && builtins.hasAttr "sha256" spec
        then
          spec //
          { outPath = callFunctionWith spec (getFetcher spec) { }; }
        else spec
      ) sources;
  toFix = builtins.foldl' (flip extends) (self: {}) ([ niv-overlay sources-overlay ] ++ overlays);
in
  fix toFix
